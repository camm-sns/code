# DAKOTA INPUT FILE: dakota_pstudy.in for parallel Case 1

method,
        nl2sol
          max_iterations = 200
          convergence_tolerance = 1e-8
          #absolute_conv_tol = 1e-3
          #x_conv_tol = 1e-3
          #function_precision = 1e-3

variables,
        continuous_state = 2
          initial_state    0.42 0.029
          #upper_bounds    0.5
          #lower_bounds    0.3
          descriptor 'FF1' 'e0'

        continuous_design = 4
          cdv_initial_point 1.0e-8  0.0    0.0 0.5
          #upper_bounds      1.0e-7  0.0    0.029 0.0 1.0
          #lower_bounds      1.0e-8 -2.0e-8 0.029 0.0 0.4
          cdv_descriptor  'b0' 'b1' 'e1' 'c0'


# Case 1: Run DAKOTA in parallel and launch M-1 serial analysis jobs at once
#         Do not specify any evaluation concurrency (handled by parallel 
#	  scheduler)
#         fork interface is recommended
interface,
	fork
# In an M processor allocation, by default DAKOTA will configure with
# a master scheduler with M-1 slave analysis processes.  Overriding
# this with static_scheduling will avoid this dedicated master and use
# all M processors, but then each batch of M analyses will have to
# complete before the next M are scheduled.  This may be useful if all
# evaluations are known to take the same processor time:
	  #evaluation_static_scheduling
	  analysis_driver = 'opt_driver'
	    parameters_file = 'params.in'
	    results_file = 'results.out'
	    file_tag
	    file_save

responses,
	calibration_terms = 1
	numerical_gradients
		method_source dakota
		interval_type forward
                fd_gradient_step_size = 0.01
	no_hessians
